# 阶段性修复记录

> 记录近期在 Chat/Research 流程上的修复与改进，便于后续排查与回溯。

## 2025-11-02

### 普通聊天禁止自动生成 Artifact
- **变更位置**：`ai-chatbot-main/app/(chat)/api/chat/route.ts`
- **调整内容**：新增 `allowArtifacts` 开关并默认设为 `false`；普通聊天不再注入 `createDocument` / `updateDocument` 工具，只保留 `requestSuggestions`。
- **目的**：阻止常规对话时模型调用文档工具导致 Artifact 面板意外弹出。

### Research 代理路由修复
- **变更位置**：`ai-chatbot-main/app/(chat)/api/research/stream/route.ts`
- **调整内容**：代理地址改为 `${RESEARCH_API_URL}/api/research/stream`，与 FastAPI 真实路由一致。
- **目的**：解决点击 “Start Research” 时 404 的问题，确保多智能体链路可用。

### 研究 Prompt 归一化
- **变更位置**：`ai-chatbot-main/components/chat.tsx`
- **调整内容**：
  - 优先使用输入框内容或最新用户消息作为研究主题；仅在缺少用户输入时回退到 AI 回复。
  - 手动 “Research This Topic” 按钮共用同一套 prompt。
  - `handleStartResearch` 对 prompt 进行 `trim()`。
- **目的**：避免 “Start Research” 使用模型免责声明或旧问题作为研究主题。

### 关闭普通对话的 Artifact 数据流
- **变更位置**：`ai-chatbot-main/components/data-stream-handler.tsx`
- **调整内容**：加入 `ENABLE_ARTIFACT_STREAM` 开关并默认禁用，从而停止普通聊天阶段监听 artifact delta。
- **目的**：彻底杜绝大语言模型在普通聊天中控制 Artifact 面板的能力。

### 提示词提取策略补充
- **变更位置**：`ai-chatbot-main/components/chat.tsx`
- **调整内容**：
  - 新增输入框提取逻辑（`normalizedInputPrompt`）。
  - 手动按钮会在无有效 prompt 时禁用，避免空调用。
- **目的**：保障手动触发研究时总能使用用户当前意图。

## 后续改进建议
1. **Prompt 策略**：可继续微调 `lib/ai/prompts.ts` 中 `regularPrompt`，明确告知模型“普通聊天禁止新建文档，需用户明确要求或进入研究模式”。
2. **Artifact 复用方案**：若未来需要在研究完成后展示报告，可另行设计“分享给聊天”的操作，在 Research 面板内显式触发。
3. **测试覆盖**：补充 Playwright 场景，验证普通聊天不再触发 Artifact、研究按钮使用当前输入等关键路径。*** End Patch*** End Patch


一、Phase 2/Phase 3 的目标回顾

  - Phase 2 后端已经实现了标准的 SSE 工作流：START → PLAN → PROGRESS × N → DONE/ERROR，并且在每个阶段即时 yield 事件，确保前端能在 <100ms 内收到更新。
  - Phase 3 的 UI 设计报告在此基础上做了两点关键增强：
      1. 双触发模式：AI 自动给出“可研究”提示，同时提供常驻的“Research This Topic”手动按钮——当前实现已满足。
      2. 实时进度 + 直接展示：Research 面板要实时显示每个步骤的进展，并在完成后直接展示研究产出，不再走“再发回聊天”的复杂流程。这要求 SSE 流畅传到浏览器。

  二、现实运行状态

  - 从 FastAPI 日志看，后端工作流稳定推进：planner / researcher / writer 各自完成，create_progress_event、create_done_event 都被触发。
  - 浏览器端面板却停留在 “Connecting to research backend… 0%”。researchProgress 的 events 数组一直空，status 维持 connecting。
  - Next.js 代理 (app/(chat)/api/research/stream/route.ts) 多次报 HeadersTimeoutError: fetch failed。这意味着它在等待 FastAPI 返回响应头（包含 Content-Type: text/event-stream）时超时，被 undici 直接中断；结果 SSE 还没开始就被断开。

  三、问题根源

  1. 首字节阻塞
     代理在 fetch(backendUrl) 时，会等后端发送响应头。若在生成 START 事件前就执行耗时操作（例如 planner_agent 调用 DeepSeek），首个 SSE chunk就被推迟。undici 的默认 headersTimeout 是 30s，超过即报错。从日志看长达 90s 的请求，说明规划/写作阶段占
     用了大量时间，导致首字节无法及时返回。
  2. 代理串流实现加重了等待
     目前实现会在拿到 headers 后再进入 ReadableStream 循环并落库。只要 fetch 在 headers 阶段超时，整个流程就终止，前端得不到任何事件。
  3. 前端缺少容错
     useResearchProgress 没有自动重连策略，一旦 fetchEventSource 抛错就停留在 0%。用户需要手工重试才能继续。

  四、与 Phase 3 设计的偏差

  - 报告强调“实时进度”和“非阻塞体验”。现在的 0% 卡住与设计目标完全相反，用户看不到任何中间步骤。
  - 设计里提到“研究结果直接展示”，而目前由于 DONE 事件到达不了浏览器，自然没有任何报告展示。
  - Phase 3 特意强调“容错/双触发”，前端按钮逻辑已经实现；但 SSE 通道是关键路径，需要恢复才能兑现“实时可感知”的体验。

  五、后端 API 逻辑梳理

  - FastAPI research_stream 中的 event_generator 顺序：
      1. yield create_start_event(prompt) ——理论上应立即发送。
      2. 调 planner_agent → yield create_plan_event(steps)。
      3. 遍历步骤，执行 executor_agent_step，每次 yield create_progress_event(...)。
      4. 最后 yield create_done_event(final_report)。
  - 若 planner_agent 或某个 executor（尤其是 writer）耗时久、返回结果特别大，就会阻塞流程。即使 Python 端最终发出了 DONE 事件，代理已在 headers 阶段中断，浏览器无法接收。

  六、前端调用链回顾

  - researchPrompt 固化后，由 useResearchProgress 调用 /api/research/stream。
  - Next.js 代理拉起 FastAPI，再把 SSE 重放给浏览器并记录到 research_tasks 表。
  - 浏览器端 fetchEventSource 负责解析 SSE，写入进度面板。当前因为 headers 超时，onopen 进不到成功分支，status 一直停在 connecting。

  七、整体分析与建议

  1. 保证首个 SSE 事件立即发出
      - 在 FastAPI 中，确保 yield create_start_event(prompt) 发生在任何外部 API 调用之前；必要时把 planner 调用放到异步任务或先发 start 再执行 planner。
  2. 调大或取消代理的 headers timeout
      - 可以使用 undici 的 Agent 自定义 headersTimeout（例如 2-3 分钟），或改用 Node 原生 HTTP 请求手动处理流，不使用默认超时时间。这样即使 planner/writer耗时，也不会提前中断。
  3. 异步写入数据库
      - 目前每个 SSE chunk 都 await updateResearchTaskRecord，如果 Neon 网络抖动会阻塞流。可以考虑 void updateResearchTaskRecord(...).catch(...) 或将持久化放到队列里，以免影响 streaming。
  4. 前端增加重连提示
      - useResearchProgress 的 onerror 中可以提示“后端仍在处理，稍后自动重连”，并带上 taskId 重连，以符合 Phase 3 “容错设计”原则。
  5. 确认 DONE 事件展示
      - 在恢复 SSE 后，需要验证 ResearchProgress 可以显示 done 的详情。现在 getEventDescription 对 report 只显示“Research report generated”，可能还需要设计一个“下载/复制”操作，或在后续阶段把报告同步到 Artifact/Notes。
  6. 符合设计文档的整体验收
      - 当前双触发按钮、研究面板布局、成本优化已经符合 Phase 3 目标。
      - 唯一缺口是“实时进度 + 直接展示”。只要解决超时问题并确保最终报告显示，前后端就能真正满足 2.0 方案中“实时、简化、统一”的要求。

  总结：代码和 UI 已按 Phase 3 设计搭建好骨架，关键是让 SSE 首字节顺利抵达浏览器。一旦解决 headers timeout（发送 start 事件提前、调整 fetch 超时），前端就能实时收到 START/PLAN/PROGRESS/DONE，Research 面板会符合 0→100% 的预期，研究结果也能直接展
  示在面板内。

